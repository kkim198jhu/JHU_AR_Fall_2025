<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Babylon.js AR</title>
    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>

    <!-- BabylonJS core + loaders -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true);

      const createScene = async function () {
        const scene = new BABYLON.Scene(engine);

        // Camera + light
        const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(canvas, true);
        camera.inputs.removeByType("FreeCameraGamepadInput");

        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.7;

        // Demo geometry
        const sphere = BABYLON.MeshBuilder.CreateSphere("sphere", { diameter: 2 }, scene);
        sphere.position.y = 1;
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 6, height: 6 }, scene);
        ground.isPickable = true;

        // Load model
        const MODEL_URL = "assets/model.glb";
        let modelPrefab = null;
        const result = await BABYLON.SceneLoader.ImportMeshAsync(null, "", MODEL_URL, scene);
        modelPrefab = new BABYLON.TransformNode("prefab", scene);
        result.meshes.forEach(m => m.parent = modelPrefab);
        modelPrefab.setEnabled(false);

        // Spawn tracking (replaces the old single 'spawned' variable)
        const spawnedObjects = [];
        let activeSpawn = null;

        // Spawn function (always creates a new clone)
        function spawnModelAt(position) {
          if (!modelPrefab) return;

          const clone = modelPrefab.clone("spawned_" + Date.now());
          if (!clone) return;
          clone.setEnabled(true);
          clone.position.copyFrom(position);

          // If the prefab has child meshes, ensure they're usable
          clone.getChildMeshes().forEach(m => {
              m.isPickable = false; // optional
          });

          spawnedObjects.push(clone);
          activeSpawn = clone;
        }

        // WebXR setup
        const xr = await scene.createDefaultXRExperienceAsync({
          uiOptions: { sessionMode: "immersive-ar" },
          optionalFeatures: true
        });

        // Disable default camera inputs that respond to gamepads/joystick in XR
        try {
          xr.baseExperience.camera.inputs.clear();
        } catch (e) {
          // if something's different in this version, ignore silently
          console.warn("Could not clear XR camera inputs:", e);
        }

        let rightController = null;
        xr.input.onControllerAddedObservable.add(ctrl => {
          if (ctrl.inputSource && ctrl.inputSource.handedness === "right") {
            rightController = ctrl;
          }

          // Extra safety: clear thumbstick axis observable on this controller
          ctrl.motionController?.getComponent("xr-standard-thumbstick")
              ?.onAxisValueChangedObservable.clear();
        });
        xr.input.onControllerRemovedObservable.add(ctrl => {
          if (rightController && ctrl.uniqueId === rightController.uniqueId) rightController = null;
        });

        // Controller logic
        let prevTrigger = false;
        const moveSpeed = 0.05;
        scene.onBeforeRenderObservable.add(() => {
          if (!rightController || !rightController.inputSource) return;
          const gp = rightController.inputSource.gamepad;
          if (!gp) return;

          // Trigger to place
          const triggerVal = gp.buttons[0]?.value || 0;
          const triggerPressed = triggerVal > 0.15;

          if (triggerPressed && !prevTrigger) {
            const ray = rightController.getForwardRay?.(10) || scene.activeCamera.getForwardRay(10);
            const pick = scene.pickWithRay(ray, m => m === ground);
            if (pick && pick.hit) spawnModelAt(pick.pickedPoint);
          }
          prevTrigger = triggerPressed;

          // Thumbstick to move the most recently spawned object
          if (activeSpawn) {
            const axisX = gp.axes[2] ?? gp.axes[0] ?? 0;
            const axisY = gp.axes[3] ?? gp.axes[1] ?? 0;
            if (Math.abs(axisX) > 0.02 || Math.abs(axisY) > 0.02) {
              const camF = scene.activeCamera.getForwardRay().direction.clone();
              camF.y = 0; camF.normalize();
              const camR = BABYLON.Vector3.Cross(camF, BABYLON.Vector3.Up()).normalize();
              const move = camR.scale(axisX * moveSpeed).add(camF.scale(axisY * moveSpeed));
              activeSpawn.position.addInPlace(move);
            }
          }
        });

        return scene;
      };

      (async function () {
        const scene = await createScene();
        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
      })();
    </script>
  </body>
</html>
