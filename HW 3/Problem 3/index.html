<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Babylon.js AR</title>
    <style>
      html, body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }
      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>
  </head>
  <body>
    <canvas id="renderCanvas"></canvas>

    <!-- BabylonJS core + loaders -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

    <script>
      const canvas = document.getElementById("renderCanvas");
      const engine = new BABYLON.Engine(canvas, true);

      const createScene = async function () {
        const scene = new BABYLON.Scene(engine);

        // Camera + light
        const camera = new BABYLON.FreeCamera("camera1", new BABYLON.Vector3(0, 5, -10), scene);
        camera.setTarget(BABYLON.Vector3.Zero());
        camera.attachControl(canvas, true);
        camera.inputs.removeByType("FreeCameraGamepadInput");

        const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
        light.intensity = 0.7;

        // Ground (pickable)
        const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 6, height: 6 }, scene);
        ground.isPickable = true;

        // Load model
        const MODEL_URL = "assets/model.glb";
        let modelPrefab = null;
        const prefabChildMeshes = [];
        const result = await BABYLON.SceneLoader.ImportMeshAsync(null, "", MODEL_URL, scene);
        modelPrefab = new BABYLON.TransformNode("prefab", scene);
        result.meshes.forEach(m => {
          if (m instanceof BABYLON.AbstractMesh) {
            m.parent = modelPrefab;
            prefabChildMeshes.push(m);
          }
        });
        modelPrefab.setEnabled(false);

        // Spawn tracking
        const spawnedObjects = [];
        let activeSpawn = null;

        // Spawn function (clone meshes individually)
        function spawnModelAt(position) {
          if (!modelPrefab) return;

          const timestamp = Date.now();
          const root = new BABYLON.TransformNode("spawned_" + timestamp, scene);

          prefabChildMeshes.forEach((srcMesh, idx) => {
            const clone = srcMesh.clone(srcMesh.name + "_clone_" + timestamp + "_" + idx);
            if (clone) {
              clone.parent = root;
              clone.isPickable = false;
            }
          });

          const children = root.getChildMeshes();
          if (children.length === 0) {
            // no fallback per request â€” do nothing if cloning failed
            root.dispose();
            return;
          }

          root.setEnabled(true);
          root.position.copyFrom(position);
          spawnedObjects.push(root);
          activeSpawn = root;
          return root;
        }

        // WebXR setup
        const xr = await scene.createDefaultXRExperienceAsync({
          uiOptions: { sessionMode: "immersive-ar" },
          optionalFeatures: true
        });

        // disable XR camera inputs
        xr.baseExperience.camera.inputs.clear();

        let rightController = null;
        xr.input.onControllerAddedObservable.add(ctrl => {
          if (ctrl.inputSource && ctrl.inputSource.handedness === "right") {
            rightController = ctrl;
          }

          ctrl.motionController?.getComponent("xr-standard-thumbstick")
            ?.onAxisValueChangedObservable.clear();

          xr.baseExperience.camera.inputs.clear();
        });
        xr.input.onControllerRemovedObservable.add(ctrl => {
          if (rightController && ctrl.uniqueId === rightController.uniqueId) rightController = null;
        });

        // Controller logic
        let prevTrigger = false;
        const moveSpeed = 0.05;
        scene.onBeforeRenderObservable.add(() => {
          if (!rightController || !rightController.inputSource) return;
          const gp = rightController.inputSource.gamepad;
          if (!gp) return;

          const triggerVal = gp.buttons[0]?.value || 0;
          const triggerPressed = triggerVal > 0.15;

          if (triggerPressed && !prevTrigger) {
            const ray = rightController.getForwardRay?.(10) || scene.activeCamera.getForwardRay(10);
            const pick = scene.pickWithRay(ray, m => m === ground);
            if (pick && pick.hit) spawnModelAt(pick.pickedPoint);
          }
          prevTrigger = triggerPressed;

          if (activeSpawn) {
            const axisX = gp.axes[2] ?? gp.axes[0] ?? 0;
            const axisY = gp.axes[3] ?? gp.axes[1] ?? 0;
            if (Math.abs(axisX) > 0.02 || Math.abs(axisY) > 0.02) {
              const camF = scene.activeCamera.getForwardRay().direction.clone();
              camF.y = 0; camF.normalize();
              const camR = BABYLON.Vector3.Cross(camF, BABYLON.Vector3.Up()).normalize();
              const move = camR.scale(axisX * moveSpeed).add(camF.scale(axisY * moveSpeed));
              activeSpawn.position.addInPlace(move);
            }
          }
        });

        return scene;
      };

      (async function () {
        const scene = await createScene();
        engine.runRenderLoop(() => scene.render());
        window.addEventListener("resize", () => engine.resize());
      })();
    </script>
  </body>
</html>
